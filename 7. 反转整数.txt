  7. 反转整数
  颠倒整数
给定一个 32 位有符号整数，将整数中的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。

int reverse(int x) {
    /*取余计算 取一位一位
    //存在的问题：
    1.负数--->变为正数 abs
      -2的31取绝对值会溢出，要特殊处理
    2.溢出问题--> pow(2,31)-1
      若长度为10，考虑溢出，无法直接比较大小
       若最后一位大于2 ---> return 0
       若最后一位等于2 ---> 考虑低9位的结果会不会>pow(2,31)-1-2000000000，这样比较计算就不会溢出了
    */
    int i;
    int time = 1;
    
    int flag = 1; //用来表示 原输入的 正负 符号  1为正，-1为负
    
    //1.变为正数
    if(x<0)
    {
        flag = -1;
        if(x == (int)(pow(-2,31)))//##除了这个数以外的数，都能直接取绝对值
            return 0;
        x = abs(x);  //都用正数来进行计算，算完再*flag 变成负数    
        printf("取绝对值：%ld\n",x);
    }
    
    int result  = 0;    //保存反转计算结果
    int buf[10] = {0};  //保存每一位
    int len = 0;        //保存长度

    //2.取每一位
    while(x)
    {       
        buf[len]=x%10;    //低位数组 存 原最低位
        len++;  //len为数据长度 [0] -> [len-1]     
        
        x=x/10; //先 取余，再 计算出新整数 
    }
    //printf("%d\n",len);
    
    for(i = 0;i<len;i++)
    {
        printf("%d ",buf[i]);
    }
     printf("\n");
    
    //3.检查溢出问题 
    //-2147483648 在前面预处理过，
    //所以只考虑：0 ~ 2147483647 
    //输入为int类型，所以最大长度只能是10位，所以不用考虑位数溢出。

    if(len==10)//10位最大不能超过 2147483648-1 
    {
        if(buf[0] > 2)
            return 0;
        if(buf[0] == 2)
        {                        
            for(i = 9; i>= 1; i--)//计算9位数
            {
                result = result+buf[i]*time;  //最大-2147483648 ~ 2147483648-1  溢出怎么办？
                time = time*10;
            } 
            printf("前9位：%d\n",result);
            
            //-2147483648
            // 8463847412
            // 2147483648
            // -126087180
    /* pow在printf中问题 
    //int max_9 =pow(2,31)-2000000000-1 ;
    //int nmax_9 = pow(2,31)-2000000000;
    //printf("int max = %ld\n", max_9); 
    //printf("int max = %ld\n", (int)pow(2,31));//##必须加int转换类型 否则double类型有问题
    */
            if(result > (pow(2,31)-2000000000-1) ) 
                 return 0;
        }
      
    }

    //4.计算没溢出的结果
    time = 1;
    result = 0;
    for(i=len-1; i>=0; i--)
    {
        result = result+buf[i]*time;  //最大-2147483648 ~ 2147483648-1  溢出怎么办？
        time = time*10;
    }
    printf("%d\n",result);
    
    return flag*result;
        
}